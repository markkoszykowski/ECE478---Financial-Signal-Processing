%% Problem Set 5 ECE478 Mark Koszykowski

clc;
clear;
close all;
%% 1


N = 1e6;

heavyTailDistributions = containers.Map();

% calculate scaling factor of Cauchy to make P(|X| < 1) equal to Normal
normalCauchyScale = @(alpha) (1 / pi) * atan(1 / alpha) + (1 / 2) ...
     - ((1 / pi) * atan(-1 / alpha) + (1 / 2)) ...
     - (normcdf(1) - normcdf(-1));
alpha = fzero(normalCauchyScale, 0.5);

% store heavy tail distributions in MATLAB map
nus = [5 10];
heavyTailDistributions("Normal") = randn([1 N]);
heavyTailDistributions("Cauchy (\alpha=" + alpha + ")") = alpha * trnd(1, [1 N]);
for nu = nus
    heavyTailDistributions("Students' T (\nu=" + nu + ")") = trnd(nu, [1 N]) / sqrt(nu / (nu - 2));
end

% plot histrograms to approximate PDFs
figure;
i = 1;
fractions = zeros([1 length(heavyTailDistributions.keys)]);
for distribution = heavyTailDistributions.keys
    distribution = string(distribution);
    samples = heavyTailDistributions(distribution);

    subplot(2, 2, i)
    histogram(samples);
    title(distribution + " Distribution");
    xlabel("{\it x}");
    ylabel("{\it f(x)}");

    % compute fraction of random samples |X| > 4
    fractions(i) = length(samples(abs(samples) > 4)) / length(samples);
    i = i + 1;
end

% plot fraction of outliers (|X| > 4) for distributions
figure;
bar(fractions);
title("Fraction of |X| > 4 for Different Distributions (N=" + N + ")");
ylabel("Fraction");
xticklabels(heavyTailDistributions.keys);

text(1:length(fractions), fractions, num2str(fractions'), ...
    "vert", "bottom", "horiz", "center"); 
box off
%% 2


disp("2)");

N = 250;

vt = randn([1 N]);

% define zeros and poles of ARMA filter
zARMA = [-0.2; -0.5];
pARMA = [0.8; 0.7];

[bARMA, aARMA] = zp2tf(zARMA, pARMA, 1);

rtARMA = filter(bARMA, aARMA, vt);

M = 10;
% a

threshold = 0.2;

[rho, lags] = autocorr(rtARMA, NumLags=M);

figure;
plot(lags, rho);
title("\rho({\itm}) of {\itr_{t}} Generated by ARMA");
xlabel("{\itm}");
ylabel("\rho({\itm})");
% b

% create Toeplitz matrix
C = toeplitz(rho);
eigenvalues = eig(C);
% display warning if any eigenvalues are negative
if any(eigenvalues < 0)
    disp(length(eigenvalues(eigenvalues < 0)) + " negative eigenvalues");
end
% c

[L, D, perm] = ldl(C, "vector");
% d

% compute and store all AR coefficients using Levinson-Durbin recursion up
% to length M
F = zeros([M + 1 M + 1]);
P = zeros([M + 1 1]);
for m = 0:M
    [FPEF_a, P(m + 1), kappa] = levinson(rho, m);
    F(m + 1, :) = padarray(fliplr(FPEF_a), [0 M - m], "post");
end
disp("Reflection coefficients:");
disp(kappa.');
% e

Pm = F * C * F.';

% ensure that diagonal(FCF') = Pm is true
assert(all(abs(diag(Pm) - P) <= eps*1e1), "FCF' diagonal is not equal to prediction error powers");

% display warning if LDL decomposition and Levinson-Durbin recursion do not
% have analagous results
if any(abs(F - L^-1) > eps*1e1, "all")
    disp("F matrix from Levinson-Durbin recursion is not equal to L^-1 from LDL decomposition");
end
if any(abs(diag(D) - P) > eps*1e1, "all")
    disp("P prediction error powers from Levinson-Durbin recursion is not equal to diagonal of D from LDL decomposition");
end
% f

% compute AR coefficients using built with Least-Squares approximation
a_LS = ar(rtARMA, M, "ls").A;

disp(newline + "AR coefficients from Levinson-Durbin recursion (M=" + M + "):");
disp(fliplr(F(M + 1, :)));

disp("AR coefficients from Least-Squares fit (M=" + M + "):");
disp(a_LS);
disp(newline);
%% 3


disp("3)");

% add pole for ARIMA filter
pARIMA = [0.99; pARMA];

[~, aARIMA] = zp2tf(zARMA, pARIMA, 1);

rtARIMA = filter(bARMA, aARIMA, vt);

figure;
plot(rtARMA, "DisplayName", "ARMA");
hold on;
plot(rtARIMA, "DisplayName", "ARIMA");
title("{\itr_{t}} generated by ARMA and ARIMA");
legend("Location", "Best");
xlabel("{\itt}");
ylabel("{\itr_{t}}");

% rerun all code from Questions 2 of newly generated signal
generateAR(rtARIMA, M, "\rho({\itm}) of {\itr_{t}} Generated by ARIMA");

% compute difference of newly generated signal and rerun all code from
% Question 2
stARIMA = rtARIMA - [0 rtARIMA(1:end-1)];

generateAR(stARIMA, M, "\rho({\itm}) of {\its_{t}} Generated by ARIMA");
%% 4


disp("4)");

% redo last two Questions but feeding in Students' T distribution random
% samples
nu = 5;
vtStudents = trnd(nu, [1 N]) / sqrt(nu / (nu - 2));

rtStudentsARMA = filter(bARMA, aARMA, vtStudents);
rtStudentsARIMA = filter(bARMA, aARIMA, vtStudents);

generateAR(rtStudentsARMA, M, "\rho({\itm}) of {\itr_{t}} Generated by ARMA with Students' T");

generateAR(rtStudentsARIMA, M, "\rho({\itm}) of {\itr_{t}} Generated by ARIMA with Students' T");

stStudentsARIMA = rtStudentsARIMA - [0 rtStudentsARIMA(1:end - 1)];

generateAR(stStudentsARIMA, M, "\rho({\itm}) of {\its_{t}} Generated by ARIMA with Students' T");
%% 5


delta = [0.3; 0.5];
G = [0.99 0; 0.3 0.3];

% define zeros and poles of ARMA filter for u(t)
z = [-0.2; -0.3];
p = [0.2; 0.5];

[b, a] = zp2tf(z, p, 1);

A = [3 4; 2 3];
% a

% simple linear scaling of entire equation and all constiuents
deltaPrime = A * delta;
GPrime = A * G;
% b & c

% generate and plot a(t) and b(t) and all the necessary information to
% construct them
nu = 5;
plotSignals = 1;
[rts, at, bt, ut, vt, sigma0] = getUnderlyingSignals(delta, G, A, b, a, nu, N, plotSignals);
% d

coefficientsOfCointegration = A^-1;
% e

M = 20;
vars = "{\itr_{it}}'s";
titles = ["N(0,\sigma_{0}^{2}) (\sigma_{0}=" + sigma0 + ")"; "Students' T (\nu=" + nu + ")"];
ys = ["\rho_{1}({\itm})"; "\rho_{2}({\itm})"; "\rho_{12}({\itm})"];
plotAutoCrossCorrs(rts, M, vars, ys, titles);
% f

% convert rit to sit using a simple filter
bs = [1 -1];
as = [1];

sts = zeros(size(rts));
for i = 1:size(sts, 3)
    sts(1, :, i) = filter(bs, as, rts(1, :, i));
    sts(2, :, i) = filter(bs, as, rts(2, :, i));
end

vars = "{\its_{it}}'s";
ys = ["\rho_{{\its}1}({\itm})"; "\rho_{{\its}2}({\itm})"; "\rho_{{\its}1{\its}2}({\itm})"];
plotAutoCrossCorrs(sts, M, vars, ys, titles);
% g

xi = randn([1 N]);

% compute c(t) using a simple filter
bc = [1];
ac = [1 -0.99];

ct = filter(bc, ac, xi);
cr1ts = [ct; at];

var = "{\itc_{t}} and {\itr_{1t}}";
ys = ["\rho_{{\itc}}({\itm})"; "\rho_{1}({\itm})"; "\rho_{{\itc}1}({\itm})"];
plotAutoCrossCorrs(cr1ts, M, var, ys);

cr2ts = zeros(size(rts));
for i = 1:size(rts, 3)
    cr2ts(:, :, i) = [ct; rts(2, :, i)];
end

var = "{\itc_{t}} and {\itr_{2t}}";
ys = ["\rho_{{\itc}}({\itm})"; "\rho_{2}({\itm})"; "\rho_{{\itc}2}({\itm})"];
plotAutoCrossCorrs(cr2ts, M, var, ys, titles);